{"version":3,"file":"chunk-ArchAPI.js","sources":["../../../../../web-components/src/lib/ArchAPI.ts"],"sourcesContent":["import { identity } from \"./helpers\";\nimport {\n  ApiParams,\n  Collection,\n  CollectionIdNamePairs,\n  Dataset,\n  FilteredApiResponse,\n  ObjectApiResponse,\n  PublishedDatasetInfo,\n  PublishedDatasetInfoApiResponse,\n  PublishedDatasetMetadata,\n  PublishedDatasetMetadataApiResponse,\n  ResponseError,\n  Team,\n  User,\n  UserUpdate,\n} from \"./types\";\n\nexport default class ArchAPI {\n  static BasePath = \"/api\";\n\n  static CSRF_REGEX = /csrftoken=([^;$]+)/;\n\n  static getCsrfHeader(): { \"X-CSRFToken\"?: string } {\n    /**\n     * Gets an object describing a CSRF header taking the value of the CSRF token\n     * found in session cookie.\n     */\n    const csrfMatch = ArchAPI.CSRF_REGEX.exec(\n      decodeURIComponent(document.cookie)\n    );\n    if (!csrfMatch) {\n      return {};\n    }\n    return { \"X-CSRFToken\": csrfMatch[1] };\n  }\n\n  static async jsonRequest<Item_T, Resp_T>(\n    method: \"DELETE\" | \"GET\" | \"PATCH\" | \"POST\" | \"PUT\",\n    path: string,\n    params?: ApiParams<Item_T>,\n    data?: Item_T,\n    responseTranslator?: (response: unknown) => Resp_T\n  ): Promise<Resp_T> {\n    // Construct the search params string.\n    const paramsStr = !params\n      ? \"\"\n      : \"?\" +\n        new URLSearchParams(\n          params.map(([k, op, v]) => [\n            `${String(k)}${op === \"!=\" ? \"!\" : \"\"}`,\n            String(v),\n          ])\n        ).toString();\n    let headers = {\n      accept: \"application/json\",\n      \"content-type\": \"application/json\",\n    };\n    let body = null;\n    if (method !== \"GET\") {\n      headers = { ...headers, ...ArchAPI.getCsrfHeader() };\n      if (data) {\n        body = JSON.stringify(data);\n      }\n    }\n    const res = await fetch(`${ArchAPI.BasePath}${path}${paramsStr}`, {\n      method,\n      headers,\n      body,\n    });\n    // Throw a ResponseError on not-ok status.\n    if (!res.ok) {\n      throw new ResponseError(res);\n    }\n    // Return null for ACCEPTED and NO CONTENT responses.\n    if (res.status === 202 || res.status === 204) {\n      return null as Resp_T;\n    }\n    // Attempt to decode JSON body and apply any responseTranslator.\n    return (responseTranslator || identity)(await res.json()) as Resp_T;\n  }\n\n  static get collections() {\n    return {\n      get: (params: ApiParams<Collection> = []) =>\n        ArchAPI.jsonRequest<Collection, FilteredApiResponse<Collection>>(\n          \"GET\",\n          \"/collections\",\n          params\n        ),\n    };\n  }\n\n  static get datasets() {\n    return {\n      get: (params: ApiParams<Dataset> = []) =>\n        ArchAPI.jsonRequest<Dataset, FilteredApiResponse<Dataset>>(\n          \"GET\",\n          \"/datasets\",\n          params\n        ),\n\n      updateTeams: (datasetId: Dataset[\"id\"], teams: Array<Team>) =>\n        ArchAPI.jsonRequest<Array<Team>, null>(\n          \"POST\",\n          `/datasets/${datasetId}/teams`,\n          undefined,\n          teams\n        ),\n\n      publication: {\n        info: (datasetId: Dataset[\"id\"]) =>\n          ArchAPI.jsonRequest<undefined, PublishedDatasetInfo>(\n            \"GET\",\n            `/datasets/${datasetId}/publication`,\n            undefined,\n            undefined,\n            (response) => {\n              const info = Object.assign({}, response) as PublishedDatasetInfo;\n              info.time = new Date(\n                (response as PublishedDatasetInfoApiResponse).time\n              );\n              return info;\n            }\n          ),\n\n        metadata: {\n          get: (datasetId: Dataset[\"id\"]) =>\n            ArchAPI.jsonRequest<undefined, PublishedDatasetMetadataApiResponse>(\n              \"GET\",\n              `/datasets/${datasetId}/publication/metadata`\n            ),\n\n          update: (\n            datasetId: Dataset[\"id\"],\n            metadata: PublishedDatasetMetadata\n          ) =>\n            ArchAPI.jsonRequest<PublishedDatasetMetadata, null>(\n              \"POST\",\n              `/datasets/${datasetId}/publication/metadata`,\n              undefined,\n              metadata\n            ),\n        },\n\n        unpublish: (datasetId: Dataset[\"id\"]) =>\n          ArchAPI.jsonRequest<undefined, null>(\n            \"DELETE\",\n            `/datasets/${datasetId}/publication`\n          ),\n      },\n    };\n  }\n\n  static get users() {\n    return {\n      get: (userId: User[\"id\"]) =>\n        ArchAPI.jsonRequest<User, ObjectApiResponse<User>>(\n          \"GET\",\n          `/users/${userId}`\n        ),\n      create: (user: Partial<User>, sendWelcomeEmail: boolean) =>\n        ArchAPI.jsonRequest<Partial<User>, ObjectApiResponse<User>>(\n          \"PUT\",\n          `/users?send_welcome=${JSON.stringify(sendWelcomeEmail)}`,\n          undefined,\n          user\n        ),\n      update: (userId: User[\"id\"], user: UserUpdate) =>\n        ArchAPI.jsonRequest<UserUpdate, ObjectApiResponse<User>>(\n          \"PATCH\",\n          `/users/${userId}`,\n          undefined,\n          user\n        ),\n    };\n  }\n\n  static async allCollectionIdNamePairs(\n    accountId: number\n  ): Promise<CollectionIdNamePairs> {\n    return (\n      (\n        await ArchAPI.jsonRequest<Collection, FilteredApiResponse<Collection>>(\n          \"GET\",\n          \"/collections\",\n          [[\"account_id\", \"=\", accountId]]\n        )\n      ).items as Array<Collection>\n    ).map((c) => [c.id, c.name]) as CollectionIdNamePairs;\n  }\n}\n"],"names":["ArchAPI","static","csrfMatch","CSRF_REGEX","exec","decodeURIComponent","document","cookie","method","path","params","data","responseTranslator","paramsStr","URLSearchParams","map","k","op","v","String","toString","headers","accept","body","getCsrfHeader","JSON","stringify","res","fetch","BasePath","ok","ResponseError","status","identity","json","collections","get","jsonRequest","datasets","updateTeams","datasetId","teams","undefined","publication","info","response","Object","assign","time","Date","metadata","update","unpublish","users","userId","create","user","sendWelcomeEmail","accountId","items","c","id","name"],"mappings":"8CAkBc,MAAOA,EAKnBC,uBAKE,MAAMC,EAAYF,EAAQG,WAAWC,KACnCC,mBAAmBC,SAASC,SAE9B,OAAKL,EAGE,CAAE,cAAeA,EAAU,IAFzB,EAGV,CAEDD,yBACEO,EACAC,EACAC,EACAC,EACAC,GAGA,MAAMC,EAAaH,EAEf,IACA,IAAII,gBACFJ,EAAOK,KAAI,EAAEC,EAAGC,EAAIC,KAAO,CACzB,GAAGC,OAAOH,KAAY,OAAPC,EAAc,IAAM,KACnCE,OAAOD,OAETE,WAPF,GAQJ,IAAIC,EAAU,CACZC,OAAQ,mBACR,eAAgB,oBAEdC,EAAO,KACI,QAAXf,IACFa,EAAU,IAAKA,KAAYrB,EAAQwB,iBAC/Bb,IACFY,EAAOE,KAAKC,UAAUf,KAG1B,MAAMgB,QAAYC,MAAM,GAAG5B,EAAQ6B,WAAWpB,IAAOI,IAAa,CAChEL,SACAa,UACAE,SAGF,IAAKI,EAAIG,GACP,MAAM,IAAIC,EAAcJ,GAG1B,OAAmB,MAAfA,EAAIK,QAAiC,MAAfL,EAAIK,OACrB,MAGDpB,GAAsBqB,SAAgBN,EAAIO,OACnD,CAEUC,yBACT,MAAO,CACLC,IAAK,CAAC1B,EAAgC,KACpCV,EAAQqC,YACN,MACA,eACA3B,GAGP,CAEU4B,sBACT,MAAO,CACLF,IAAK,CAAC1B,EAA6B,KACjCV,EAAQqC,YACN,MACA,YACA3B,GAGJ6B,YAAa,CAACC,EAA0BC,IACtCzC,EAAQqC,YACN,OACA,aAAaG,eACbE,EACAD,GAGJE,YAAa,CACXC,KAAOJ,GACLxC,EAAQqC,YACN,MACA,aAAaG,qBACbE,OACAA,GACCG,IACC,MAAMD,EAAOE,OAAOC,OAAO,CAAE,EAAEF,GAI/B,OAHAD,EAAKI,KAAO,IAAIC,KACbJ,EAA6CG,MAEzCJ,CAAI,IAIjBM,SAAU,CACRd,IAAMI,GACJxC,EAAQqC,YACN,MACA,aAAaG,0BAGjBW,OAAQ,CACNX,EACAU,IAEAlD,EAAQqC,YACN,OACA,aAAaG,8BACbE,EACAQ,IAINE,UAAYZ,GACVxC,EAAQqC,YACN,SACA,aAAaG,kBAItB,CAEUa,mBACT,MAAO,CACLjB,IAAMkB,GACJtD,EAAQqC,YACN,MACA,UAAUiB,KAEdC,OAAQ,CAACC,EAAqBC,IAC5BzD,EAAQqC,YACN,MACA,uBAAuBZ,KAAKC,UAAU+B,UACtCf,EACAc,GAEJL,OAAQ,CAACG,EAAoBE,IAC3BxD,EAAQqC,YACN,QACA,UAAUiB,SACVZ,EACAc,GAGP,CAEDvD,sCACEyD,GAEA,aAEU1D,EAAQqC,YACZ,MACA,eACA,CAAC,CAAC,aAAc,IAAKqB,MAEvBC,MACF5C,KAAK6C,GAAM,CAACA,EAAEC,GAAID,EAAEE,OACvB,EA3KM9D,EAAQ6B,SAAG,OAEX7B,EAAUG,WAAG"}