{"version":3,"file":"chunk-index.js","sources":["../../../web-components/node_modules/@internetarchive/ads-library/dist/index.js"],"sourcesContent":["// static class that encapsulates shorthands and utilities for emitting events.\nclass EventHelpers {\n    // returns event object with default options applied, overridden\n    // and extended by additional options the caller passes\n    static createEvent(eventName, options = {}) {\n        return new CustomEvent(eventName, {\n            ...EventHelpers.defaultEventOptions,\n            ...options,\n        });\n    }\n}\nEventHelpers.defaultEventOptions = {\n    composed: true,\n    bubbles: true,\n};\n\nconst isObject$1 = value => typeof value === 'object' && value !== null;\n\n// Customized for this use-case\nconst isObjectCustom = value =>\n\tisObject$1(value)\n\t&& !(value instanceof RegExp)\n\t&& !(value instanceof Error)\n\t&& !(value instanceof Date);\n\nconst mapObjectSkip = Symbol('mapObjectSkip');\n\nconst _mapObject = (object, mapper, options, isSeen = new WeakMap()) => {\n\toptions = {\n\t\tdeep: false,\n\t\ttarget: {},\n\t\t...options,\n\t};\n\n\tif (isSeen.has(object)) {\n\t\treturn isSeen.get(object);\n\t}\n\n\tisSeen.set(object, options.target);\n\n\tconst {target} = options;\n\tdelete options.target;\n\n\tconst mapArray = array => array.map(element => isObjectCustom(element) ? _mapObject(element, mapper, options, isSeen) : element);\n\tif (Array.isArray(object)) {\n\t\treturn mapArray(object);\n\t}\n\n\tfor (const [key, value] of Object.entries(object)) {\n\t\tconst mapResult = mapper(key, value, object);\n\n\t\tif (mapResult === mapObjectSkip) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet [newKey, newValue, {shouldRecurse = true} = {}] = mapResult;\n\n\t\t// Drop `__proto__` keys.\n\t\tif (newKey === '__proto__') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (options.deep && shouldRecurse && isObjectCustom(newValue)) {\n\t\t\tnewValue = Array.isArray(newValue)\n\t\t\t\t? mapArray(newValue)\n\t\t\t\t: _mapObject(newValue, mapper, options, isSeen);\n\t\t}\n\n\t\ttarget[newKey] = newValue;\n\t}\n\n\treturn target;\n};\n\nfunction mapObject(object, mapper, options) {\n\tif (!isObject$1(object)) {\n\t\tthrow new TypeError(`Expected an object, got \\`${object}\\` (${typeof object})`);\n\t}\n\n\treturn _mapObject(object, mapper, options);\n}\n\nconst UPPERCASE = /[\\p{Lu}]/u;\nconst LOWERCASE = /[\\p{Ll}]/u;\nconst LEADING_CAPITAL = /^[\\p{Lu}](?![\\p{Lu}])/gu;\nconst IDENTIFIER = /([\\p{Alpha}\\p{N}_]|$)/u;\nconst SEPARATORS = /[_.\\- ]+/;\n\nconst LEADING_SEPARATORS = new RegExp('^' + SEPARATORS.source);\nconst SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, 'gu');\nconst NUMBERS_AND_IDENTIFIER = new RegExp('\\\\d+' + IDENTIFIER.source, 'gu');\n\nconst preserveCamelCase = (string, toLowerCase, toUpperCase, preserveConsecutiveUppercase) => {\n\tlet isLastCharLower = false;\n\tlet isLastCharUpper = false;\n\tlet isLastLastCharUpper = false;\n\tlet isLastLastCharPreserved = false;\n\n\tfor (let index = 0; index < string.length; index++) {\n\t\tconst character = string[index];\n\t\tisLastLastCharPreserved = index > 2 ? string[index - 3] === '-' : true;\n\n\t\tif (isLastCharLower && UPPERCASE.test(character)) {\n\t\t\tstring = string.slice(0, index) + '-' + string.slice(index);\n\t\t\tisLastCharLower = false;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = true;\n\t\t\tindex++;\n\t\t} else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character) && (!isLastLastCharPreserved || preserveConsecutiveUppercase)) {\n\t\t\tstring = string.slice(0, index - 1) + '-' + string.slice(index - 1);\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = false;\n\t\t\tisLastCharLower = true;\n\t\t} else {\n\t\t\tisLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;\n\t\t}\n\t}\n\n\treturn string;\n};\n\nconst preserveConsecutiveUppercase = (input, toLowerCase) => {\n\tLEADING_CAPITAL.lastIndex = 0;\n\n\treturn input.replaceAll(LEADING_CAPITAL, match => toLowerCase(match));\n};\n\nconst postProcess = (input, toUpperCase) => {\n\tSEPARATORS_AND_IDENTIFIER.lastIndex = 0;\n\tNUMBERS_AND_IDENTIFIER.lastIndex = 0;\n\n\treturn input\n\t\t.replaceAll(NUMBERS_AND_IDENTIFIER, (match, pattern, offset) => ['_', '-'].includes(input.charAt(offset + match.length)) ? match : toUpperCase(match))\n\t\t.replaceAll(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier));\n};\n\nfunction camelCase(input, options) {\n\tif (!(typeof input === 'string' || Array.isArray(input))) {\n\t\tthrow new TypeError('Expected the input to be `string | string[]`');\n\t}\n\n\toptions = {\n\t\tpascalCase: false,\n\t\tpreserveConsecutiveUppercase: false,\n\t\t...options,\n\t};\n\n\tif (Array.isArray(input)) {\n\t\tinput = input.map(x => x.trim())\n\t\t\t.filter(x => x.length)\n\t\t\t.join('-');\n\t} else {\n\t\tinput = input.trim();\n\t}\n\n\tif (input.length === 0) {\n\t\treturn '';\n\t}\n\n\tconst toLowerCase = options.locale === false\n\t\t? string => string.toLowerCase()\n\t\t: string => string.toLocaleLowerCase(options.locale);\n\n\tconst toUpperCase = options.locale === false\n\t\t? string => string.toUpperCase()\n\t\t: string => string.toLocaleUpperCase(options.locale);\n\n\tif (input.length === 1) {\n\t\tif (SEPARATORS.test(input)) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn options.pascalCase ? toUpperCase(input) : toLowerCase(input);\n\t}\n\n\tconst hasUpperCase = input !== toLowerCase(input);\n\n\tif (hasUpperCase) {\n\t\tinput = preserveCamelCase(input, toLowerCase, toUpperCase, options.preserveConsecutiveUppercase);\n\t}\n\n\tinput = input.replace(LEADING_SEPARATORS, '');\n\tinput = options.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input, toLowerCase) : toLowerCase(input);\n\n\tif (options.pascalCase) {\n\t\tinput = toUpperCase(input.charAt(0)) + input.slice(1);\n\t}\n\n\treturn postProcess(input, toUpperCase);\n}\n\nclass QuickLRU extends Map {\n\tconstructor(options = {}) {\n\t\tsuper();\n\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tif (typeof options.maxAge === 'number' && options.maxAge === 0) {\n\t\t\tthrow new TypeError('`maxAge` must be a number greater than 0');\n\t\t}\n\n\t\t// TODO: Use private class fields when ESLint supports them.\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.maxAge = options.maxAge || Number.POSITIVE_INFINITY;\n\t\tthis.onEviction = options.onEviction;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\n\t// TODO: Use private class methods when targeting Node.js 16.\n\t_emitEvictions(cache) {\n\t\tif (typeof this.onEviction !== 'function') {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const [key, item] of cache) {\n\t\t\tthis.onEviction(key, item.value);\n\t\t}\n\t}\n\n\t_deleteIfExpired(key, item) {\n\t\tif (typeof item.expiry === 'number' && item.expiry <= Date.now()) {\n\t\t\tif (typeof this.onEviction === 'function') {\n\t\t\t\tthis.onEviction(key, item.value);\n\t\t\t}\n\n\t\t\treturn this.delete(key);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_getOrDeleteIfExpired(key, item) {\n\t\tconst deleted = this._deleteIfExpired(key, item);\n\t\tif (deleted === false) {\n\t\t\treturn item.value;\n\t\t}\n\t}\n\n\t_getItemValue(key, item) {\n\t\treturn item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;\n\t}\n\n\t_peek(key, cache) {\n\t\tconst item = cache.get(key);\n\n\t\treturn this._getItemValue(key, item);\n\t}\n\n\t_set(key, value) {\n\t\tthis.cache.set(key, value);\n\t\tthis._size++;\n\n\t\tif (this._size >= this.maxSize) {\n\t\t\tthis._size = 0;\n\t\t\tthis._emitEvictions(this.oldCache);\n\t\t\tthis.oldCache = this.cache;\n\t\t\tthis.cache = new Map();\n\t\t}\n\t}\n\n\t_moveToRecent(key, item) {\n\t\tthis.oldCache.delete(key);\n\t\tthis._set(key, item);\n\t}\n\n\t* _entriesAscending() {\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\tget(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\tconst item = this.cache.get(key);\n\n\t\t\treturn this._getItemValue(key, item);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\tconst item = this.oldCache.get(key);\n\t\t\tif (this._deleteIfExpired(key, item) === false) {\n\t\t\t\tthis._moveToRecent(key, item);\n\t\t\t\treturn item.value;\n\t\t\t}\n\t\t}\n\t}\n\n\tset(key, value, {maxAge = this.maxAge} = {}) {\n\t\tconst expiry =\n\t\t\ttypeof maxAge === 'number' && maxAge !== Number.POSITIVE_INFINITY ?\n\t\t\t\tDate.now() + maxAge :\n\t\t\t\tundefined;\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.set(key, {\n\t\t\t\tvalue,\n\t\t\t\texpiry\n\t\t\t});\n\t\t} else {\n\t\t\tthis._set(key, {value, expiry});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\thas(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.cache.get(key));\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.oldCache.get(key));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpeek(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this._peek(key, this.cache);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn this._peek(key, this.oldCache);\n\t\t}\n\t}\n\n\tdelete(key) {\n\t\tconst deleted = this.cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis._size--;\n\t\t}\n\n\t\treturn this.oldCache.delete(key) || deleted;\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t\tthis.oldCache.clear();\n\t\tthis._size = 0;\n\t}\n\n\tresize(newSize) {\n\t\tif (!(newSize && newSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tconst items = [...this._entriesAscending()];\n\t\tconst removeCount = items.length - newSize;\n\t\tif (removeCount < 0) {\n\t\t\tthis.cache = new Map(items);\n\t\t\tthis.oldCache = new Map();\n\t\t\tthis._size = items.length;\n\t\t} else {\n\t\t\tif (removeCount > 0) {\n\t\t\t\tthis._emitEvictions(items.slice(0, removeCount));\n\t\t\t}\n\n\t\t\tthis.oldCache = new Map(items.slice(removeCount));\n\t\t\tthis.cache = new Map();\n\t\t\tthis._size = 0;\n\t\t}\n\n\t\tthis.maxSize = newSize;\n\t}\n\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesDescending() {\n\t\tlet items = [...this.cache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\titems = [...this.oldCache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesAscending() {\n\t\tfor (const [key, value] of this._entriesAscending()) {\n\t\t\tyield [key, value.value];\n\t\t}\n\t}\n\n\tget size() {\n\t\tif (!this._size) {\n\t\t\treturn this.oldCache.size;\n\t\t}\n\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.oldCache.keys()) {\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\n\t\treturn Math.min(this._size + oldCacheSize, this.maxSize);\n\t}\n\n\tentries() {\n\t\treturn this.entriesAscending();\n\t}\n\n\tforEach(callbackFunction, thisArgument = this) {\n\t\tfor (const [key, value] of this.entriesAscending()) {\n\t\t\tcallbackFunction.call(thisArgument, value, key, this);\n\t\t}\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn JSON.stringify([...this.entriesAscending()]);\n\t}\n}\n\nconst has = (array, key) => array.some(element => {\n\tif (typeof element === 'string') {\n\t\treturn element === key;\n\t}\n\n\telement.lastIndex = 0;\n\n\treturn element.test(key);\n});\n\nconst cache = new QuickLRU({maxSize: 100_000});\n\n// Reproduces behavior from `map-obj`.\nconst isObject = value =>\n\ttypeof value === 'object'\n\t\t&& value !== null\n\t\t&& !(value instanceof RegExp)\n\t\t&& !(value instanceof Error)\n\t\t&& !(value instanceof Date);\n\nconst transform = (input, options = {}) => {\n\tif (!isObject(input)) {\n\t\treturn input;\n\t}\n\n\tconst {\n\t\texclude,\n\t\tpascalCase = false,\n\t\tstopPaths,\n\t\tdeep = false,\n\t\tpreserveConsecutiveUppercase = false,\n\t} = options;\n\n\tconst stopPathsSet = new Set(stopPaths);\n\n\tconst makeMapper = parentPath => (key, value) => {\n\t\tif (deep && isObject(value)) {\n\t\t\tconst path = parentPath === undefined ? key : `${parentPath}.${key}`;\n\n\t\t\tif (!stopPathsSet.has(path)) {\n\t\t\t\tvalue = mapObject(value, makeMapper(path));\n\t\t\t}\n\t\t}\n\n\t\tif (!(exclude && has(exclude, key))) {\n\t\t\tconst cacheKey = pascalCase ? `${key}_` : key;\n\n\t\t\tif (cache.has(cacheKey)) {\n\t\t\t\tkey = cache.get(cacheKey);\n\t\t\t} else {\n\t\t\t\tconst returnValue = camelCase(key, {pascalCase, locale: false, preserveConsecutiveUppercase});\n\n\t\t\t\tif (key.length < 100) { // Prevent abuse\n\t\t\t\t\tcache.set(cacheKey, returnValue);\n\t\t\t\t}\n\n\t\t\t\tkey = returnValue;\n\t\t\t}\n\t\t}\n\n\t\treturn [key, value];\n\t};\n\n\treturn mapObject(input, makeMapper(undefined));\n};\n\nfunction camelcaseKeys(input, options) {\n\tif (Array.isArray(input)) {\n\t\treturn Object.keys(input).map(key => transform(input[key], options));\n\t}\n\n\treturn transform(input, options);\n}\n\nfunction callJsonApi(options) {\n    const request = {\n        method: options.method,\n        headers: {\n            ...getCsrfHeader(),\n            Accept: \"application/json\",\n            \"Content-Type\": \"application/json\",\n        },\n    };\n    if (options.body) {\n        request.body = JSON.stringify(options.body);\n    }\n    return (fetch(options.url, request)\n        .then((response) => {\n        if (response.ok) {\n            return response.json();\n        }\n        else {\n            throw new Error(options.errorMessage);\n        }\n    })\n        // camelize response keys unless disabled, cast to generic response type\n        .then((json) => options.disableCamelize\n        ? json\n        : camelcaseKeys(json, { deep: true }))\n        // log error, return no response\n        .catch((error) => {\n        console.error(error);\n        return Promise.reject(options.errorMessage);\n    }));\n}\nconst CSRF_REGEX = /csrftoken=([^;$]+)/;\n/**\n * Gets an object describing a CSRF header taking the value of the CSRF token\n * found in session cookie.\n */\nconst getCsrfHeader = () => {\n    const csrfMatch = CSRF_REGEX.exec(decodeURIComponent(document.cookie));\n    if (!csrfMatch) {\n        return {};\n    }\n    return { \"X-CSRFToken\": csrfMatch[1] };\n};\n\n// browser-related utility functions\nvar UserOperatingSystem;\n(function (UserOperatingSystem) {\n    UserOperatingSystem[\"MAC\"] = \"MAC\";\n    UserOperatingSystem[\"WINDOWS\"] = \"WINDOWS\";\n    UserOperatingSystem[\"LINUX\"] = \"LINUX\";\n    UserOperatingSystem[\"OTHER\"] = \"OTHER\";\n})(UserOperatingSystem || (UserOperatingSystem = {}));\nfunction getUserOS() {\n    const userAgent = window.navigator.userAgent.toLowerCase();\n    if (userAgent.includes(\"mac\")) {\n        return UserOperatingSystem.MAC;\n    }\n    else if (userAgent.includes(\"win\")) {\n        return UserOperatingSystem.WINDOWS;\n    }\n    else if (userAgent.includes(\"linux\")) {\n        return UserOperatingSystem.LINUX;\n    }\n    else {\n        return UserOperatingSystem.OTHER;\n    }\n}\n\n// map from binary exponents to the corresponding binary data volume unit suffix\nconst _EXP_UNITS = Object.fromEntries([\"Bytes\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"ZiB\", \"YiB\"].map((unit, idx) => [idx * 10, unit]));\n/**\n * Gets a human-friendly representation of numBytes, expressed in binary units.\n *\n * @param numBytes whole number expressing the count of bytes to represent\n * @return the formatted friendly representation of the number of bytes\n */\nfunction humanBytes(numBytes) {\n    switch (numBytes) {\n        case -1:\n            return \"-1 Byte\";\n        case 0:\n            return \"0 Bytes\";\n        case 1:\n            return \"1 Byte\";\n    }\n    const exp = Math.floor(Math.log2(Math.abs(numBytes)) / 10) * 10.0;\n    const precision = exp > 0 ? 1 : 0;\n    return `${(numBytes / Math.pow(2, exp)).toFixed(precision)} ${_EXP_UNITS[exp]}`;\n}\nfunction isoStringToDateString(timestamp, includeTime = false) {\n    const dayConfig = {\n        month: \"short\",\n        day: \"numeric\",\n        year: \"numeric\",\n    };\n    const timeConfig = {\n        hour: \"numeric\",\n        minute: \"2-digit\",\n        timeZoneName: \"short\",\n    };\n    return includeTime\n        ? new Date(timestamp).toLocaleTimeString(navigator.language, {\n            ...dayConfig,\n            ...timeConfig,\n        })\n        : new Date(timestamp).toLocaleDateString(navigator.language, dayConfig);\n}\nfunction formatDate(date, includeTime = true) {\n    const _formattedDate = isoStringToDateString(date, includeTime);\n    return _formattedDate === \"Invalid Date\" ? \"\" : _formattedDate;\n}\n\nexport { EventHelpers, UserOperatingSystem, callJsonApi, formatDate, getCsrfHeader, getUserOS, humanBytes };\n//# sourceMappingURL=index.js.map\n"],"names":["EventHelpers","static","eventName","options","CustomEvent","defaultEventOptions","composed","bubbles","QuickLRU","Map","constructor","super","maxSize","TypeError","maxAge","this","Number","POSITIVE_INFINITY","onEviction","cache","oldCache","_size","_emitEvictions","key","item","value","_deleteIfExpired","expiry","Date","now","delete","_getOrDeleteIfExpired","_getItemValue","_peek","get","_set","set","_moveToRecent","_entriesAscending","has","undefined","peek","deleted","clear","resize","newSize","items","removeCount","length","slice","keys","values","Symbol","iterator","entriesDescending","i","entriesAscending","size","oldCacheSize","Math","min","entries","forEach","callbackFunction","thisArgument","call","toStringTag","JSON","stringify","UserOperatingSystem"],"mappings":"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"}